<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>【转载】frida加密参数通杀hook代码（免脱壳） | 小呆博客</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.0/css/all.min.css">
<link rel="shortcut icon" href="https://mezdosec.github.io/favicon.ico?v=1754753265455">
<link rel="stylesheet" href="https://mezdosec.github.io/styles/main.css">





<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aos@2.3.4/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="本文介绍了使用Frida进行加密参数hook的实战技巧，包括Python和JavaScript的实现，无需应用脱壳，适用于加密参数的动态分析。
一、python终极版
import frida  # 导入frida模块
import sys..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://mezdosec.github.io">
        <img src="https://mezdosec.github.io/images/avatar.png?v=1754753265455" class="site-logo">
        <h1 class="site-title">小呆博客</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
        
          <a href="/post/address" class="site-nav">
            友链
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      
    </div>
    <div class="site-footer">
       | <a class="rss" href="https://mezdosec.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">【转载】frida加密参数通杀hook代码（免脱壳）</h2>
            <div class="post-date">2024-08-09</div>
            
            <div class="post-content" v-pre>
              <p>本文介绍了使用Frida进行加密参数hook的实战技巧，包括Python和JavaScript的实现，无需应用脱壳，适用于加密参数的动态分析。</p>
<h1 id="一-python终极版">一、python终极版</h1>
<pre><code>import frida  # 导入frida模块
import sys  # 导入sys模块

jscode = &quot;&quot;&quot;
function showStacks() {
    Java.perform(function() {
        send(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()));
        var kgh = Java.use(&quot;com.kc.openset.util.VerifyUtil&quot;);
            kgh.getMD5Verify.overload('java.lang.String','java.lang.String').implementation = function (x1,x2) {
                console.log(&quot;getMD5Verify x1:&quot;,x1);
                console.log(&quot;getMD5Verify x2:&quot;,x2);
                var result = this.getMD5Verify(x1,x2);
                    console.log(result);
                    return result;
     
                
                }
    });
}

function bytesToHex(arr) {
    var str = &quot;&quot;;
    for (var i = 0; i &lt; arr.length; i++) {
        var tmp = arr[i];
        if (tmp &lt; 0) {
            tmp = (255 + tmp + 1).toString(16);
        } else {
            tmp = tmp.toString(16);
        }
        if (tmp.length == 1) {
            tmp = &quot;0&quot; + tmp;
        }
        str += tmp;
    }
    return str;
}
function bytesToBase64(e) {
    var base64EncodeChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var r, a, c, h, o, t;
    for (c = e.length, a = 0, r = ''; a &lt; c;) {
        if (h = 255 &amp; e[a++], a == c) {
            r += base64EncodeChars.charAt(h &gt;&gt; 2),
            r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4),
            r += '==';
            break
        }
        if (o = e[a++], a == c) {
            r += base64EncodeChars.charAt(h &gt;&gt; 2),
            r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4),
            r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2),
            r += '=';
            break
        }
        t = e[a++],
        r += base64EncodeChars.charAt(h &gt;&gt; 2),
        r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4),
        r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2 | (192 &amp; t) &gt;&gt; 6),
        r += base64EncodeChars.charAt(63 &amp; t)
    }
    return r
}
function bytesToString(arr) {
    if (typeof arr === 'string') {
        return arr;
    }
    var str = '',
    _arr = arr;
    for (var i = 0; i &lt; _arr.length; i++) {
        var one = _arr[i].toString(2),
        v = one.match(/^1+?(?=0)/);
        if (v &amp;&amp; one.length == 8) {
            var bytesLength = v[0].length;
            var store = _arr[i].toString(2).slice(7 - bytesLength);
            for (var st = 1; st &lt; bytesLength; st++) {
                store += _arr[st + i].toString(2).slice(2);
            }
            str += String.fromCharCode(parseInt(store, 2));
            i += bytesLength - 1;
        } else {
            str += String.fromCharCode(_arr[i]);
        }
    }
    return str;
}

Java.perform(function () {
    var secretKeySpec = Java.use('javax.crypto.spec.SecretKeySpec');
    secretKeySpec.$init.overload('[B','java.lang.String').implementation = function (a,b) {
        showStacks();
        var result = this.$init(a, b);
        send(&quot;======================================&quot;);
        send(&quot;算法名：&quot; + b + &quot;|Dec密钥:&quot; + bytesToString(a));
        send(&quot;算法名：&quot; + b + &quot;|Hex密钥:&quot; + bytesToHex(a));
        return result;
    }
    var mac = Java.use('javax.crypto.Mac');
    mac.getInstance.overload('java.lang.String').implementation = function (a) {
        showStacks();
        var result = this.getInstance(a);
        send(&quot;======================================&quot;);
        send(&quot;算法名：&quot; + a);
        return result;
    }
    mac.update.overload('[B').implementation = function (a) {
        showStacks();
        this.update(a);
        send(&quot;======================================&quot;);
        send(&quot;update:&quot; + bytesToString(a))
    }
    mac.update.overload('[B','int','int').implementation = function (a,b,c) {
        showStacks();
        this.update(a,b,c)
        send(&quot;======================================&quot;);
        send(&quot;update:&quot; + bytesToString(a) + &quot;|&quot; + b + &quot;|&quot; + c);
    }
    mac.doFinal.overload().implementation = function () {
        showStacks();
        var result = this.doFinal();
        send(&quot;======================================&quot;);
        send(&quot;doFinal结果(hex):&quot; + bytesToHex(result));
        send(&quot;doFinal结果(base64):&quot; + bytesToBase64(result));
        return result;
    }
    mac.doFinal.overload('[B').implementation = function (a) {
        showStacks();
        var result = this.doFinal(a);
        send(&quot;======================================&quot;);
        send(&quot;doFinal参数:&quot; + bytesToString(a));
        send(&quot;doFinal结果(hex):&quot; + bytesToHex(result));
        send(&quot;doFinal结果(base):&quot; + bytesToBase64(result));
        return result;
    }
        var md = Java.use('java.security.MessageDigest');
    md.getInstance.overload('java.lang.String','java.lang.String').implementation = function (a,b) {
        showStacks();
        send(&quot;======================================&quot;);
        send(&quot;算法名：&quot; + a);
        return this.getInstance(a, b);
    }
    md.getInstance.overload('java.lang.String').implementation = function (a) {
        showStacks();
        send(&quot;======================================&quot;);
        send(&quot;算法名：&quot; + a);
        return this.getInstance(a);
    }
    md.update.overload('[B').implementation = function (a) {
        showStacks();
        send(&quot;======================================&quot;);
        send(&quot;update:&quot; + bytesToString(a))
        return this.update(a);
    }
    md.update.overload('[B','int','int').implementation = function (a,b,c) {
        showStacks();
        send(&quot;======================================&quot;);
        send(&quot;update:&quot; + bytesToString(a) + &quot;|&quot; + b + &quot;|&quot; + c);
        return this.update(a,b,c);
    }
    md.digest.overload().implementation = function () {
        showStacks();
        send(&quot;======================================&quot;);
        var result = this.digest();
        send(&quot;digest结果(hex):&quot; + bytesToHex(result));
        send(&quot;digest结果(base64):&quot; + bytesToBase64(result));
        return result;
    }
    md.digest.overload('[B').implementation = function (a) {
        showStacks();
        send(&quot;======================================&quot;);
        send(&quot;digest参数:&quot; + bytesToString(a));
        var java_string = Java.use(&quot;java.lang.String&quot;);
        console.log('bArr to string: ' + java_string.$new(a));
        console.log(bytesToString(a));
        var result = this.digest(a);
        send(&quot;digest结果(hex):&quot; + bytesToHex(result));
        send(&quot;digest结果(base64):&quot; + bytesToBase64(result));
        return result;
    }
        var ivParameterSpec = Java.use('javax.crypto.spec.IvParameterSpec');
    ivParameterSpec.$init.overload('[B').implementation = function (a) {
        showStacks();
        var result = this.$init(a);
        send(&quot;======================================&quot;);
        send(&quot;iv向量:&quot; + bytesToString(a));
        send(&quot;iv向量(hex):&quot; + bytesToHex(a));
        return result;
    }
    var cipher = Java.use('javax.crypto.Cipher');
    cipher.getInstance.overload('java.lang.String').implementation = function (a) {
        showStacks();
        var result = this.getInstance(a);
        send(&quot;======================================&quot;);
        send(&quot;模式填充:&quot; + a);
        return result;
    }
    cipher.update.overload('[B').implementation = function (a) {
        showStacks();
        var result = this.update(a);
        send(&quot;======================================&quot;);
        send(&quot;update:&quot; + bytesToString(a));
        return result;
    }
    cipher.update.overload('[B','int','int').implementation = function (a,b,c) {
        showStacks();
        var result = this.update(a,b,c);
        send(&quot;======================================&quot;);
        send(&quot;update:&quot; + bytesToString(a) + &quot;|&quot; + b + &quot;|&quot; + c);
        return result;
    }
    cipher.doFinal.overload().implementation = function () {
        showStacks();
        var result = this.doFinal();
        send(&quot;======================================&quot;);
        send(&quot;doFinal结果(hex):&quot; + bytesToHex(result));
        send(&quot;doFinal结果(base64):&quot; + bytesToBase64(result));
        return result;
    }
    cipher.doFinal.overload('[B').implementation = function (a) {
        showStacks();
        var result = this.doFinal(a);
        send(&quot;======================================&quot;);
        send(&quot;doFinal参数:&quot; + bytesToString(a));
        send(&quot;doFinal结果(hex):&quot; + bytesToHex(result));
        send(&quot;doFinal结果(base64):&quot; + bytesToBase64(result));
        return result;
    }
    var x509EncodedKeySpec = Java.use('java.security.spec.X509EncodedKeySpec');
    x509EncodedKeySpec.$init.overload('[B').implementation = function (a) {
        showStacks();
        var result = this.$init(a);
        send(&quot;======================================&quot;);
        send(&quot;RSA密钥:&quot; + bytesToBase64(a));
        return result;
    }
    var rSAPublicKeySpec = Java.use('java.security.spec.RSAPublicKeySpec');
    rSAPublicKeySpec.$init.overload('java.math.BigInteger','java.math.BigInteger').implementation = function (a,b) {
        showStacks();
        var result = this.$init(a,b);
        send(&quot;======================================&quot;);
        //send(&quot;RSA密钥:&quot; + bytesToBase64(a));
        send(&quot;RSA密钥N:&quot; + a.toString(16));
        send(&quot;RSA密钥E:&quot; + b.toString(16));
        return result;
    }
});
&quot;&quot;&quot;


def on_message(message, data):  # js中执行send函数后要回调的函数
    if message[&quot;type&quot;] == &quot;send&quot;:
        print(&quot;[*] {0}&quot;.format(message[&quot;payload&quot;]))
    else:
        print(message)


process = frida.get_usb_device().attach('app名')  # app名
script = process.create_script(jscode)  # 创建js脚本
script.on('message', on_message)  # 加载回调函数，也就是js中执行send函数规定要执行的python函数
script.load()  # 加载脚本
sys.stdin.read()

</code></pre>
<h1 id="二-python终极版2">二、python终极版2</h1>
<pre><code># -*- coding: UTF-8 -*-
# 代码引用自 guyezhou51

import frida
import sys
import datetime


def on_message(message, data):      # 该函数可在frida中使用send(a); 输出python类型内容
    if message['type'] == 'send':
        print(&quot;[*] {0}&quot;.format(message['payload']))
    else:
        print(message)


def get_js():
    htmlstr = '''
var N_ENCRYPT_MODE = 1;
var N_DECRYPT_MODE = 2;
function showStacks() {
    var Exception = Java.use(&quot;java.lang.Exception&quot;);
    var ins = Exception.$new(&quot;Exception&quot;);
    var straces = ins.getStackTrace();
    if (undefined == straces || null == straces) {
        return;
    }
    mylog(&quot;===================== Stack strat=======================&quot;,&quot;&quot;,&quot;&quot;,0);    
    for (var i = 0; i &lt; straces.length; i++) {
        var str = &quot;   &quot; + straces[i].toString();
        mylog(str,&quot;&quot;,&quot;&quot;,0);
    }
    mylog(&quot;====================== Stack end=======================&quot;,&quot;&quot;,&quot;&quot;,0);
    Exception.$dispose();
};
//工具相关函数 
var base64EncodeChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    base64DecodeChars = new Array((-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), 62, (-1), (-1), (-1), 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, (-1), (-1), (-1), (-1), (-1), (-1), (-1), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, (-1), (-1), (-1), (-1), (-1), (-1), 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, (-1), (-1), (-1), (-1), (-1));
function bytesToHex(arr) {
    var str = '';
    arr = new Uint8Array(arr);
    var k, j;
    for (var i = 0; i &lt; arr.length; i++) {
        k = arr[i];
        j = k;
        if (k &lt; 0) {
            j = k + 256;
        }
        if (j &lt; 16) {
            str += &quot;0&quot;;
        }
        str += j.toString(16);
    }
    return str;
};
//将byte[]转成String的方法
function bytesToString(arr) {
    var str = '';
    arr = new Uint8Array(arr);
    for (var i in arr) {
        str += String.fromCharCode(arr[i]);
    }
    return str;
};
function bytesToBase64(e) {
    e = new Uint8Array(e);
    var r, a, c, h, o, t;
    for (c = e.length, a = 0, r = ''; a &lt; c;) {
        if (h = 255 &amp; e[a++], a == c) {
            r += base64EncodeChars.charAt(h &gt;&gt; 2),
                r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4),
                r += '==';
            break;
        }
        if (o = e[a++], a == c) {
            r += base64EncodeChars.charAt(h &gt;&gt; 2),
                r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4),
                r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2),
                r += '=';
            break;
        }
        t = e[a++],
            r += base64EncodeChars.charAt(h &gt;&gt; 2),
            r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4),
            r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2 | (192 &amp; t) &gt;&gt; 6),
            r += base64EncodeChars.charAt(63 &amp; t);
    }
    return r;
};
//stringToBase64 stringToHex stringToBytes
//base64ToString base64ToHex base64ToBytes
//               hexToBase64  hexToBytes    
// bytesToBase64 bytesToHex bytesToString
function mylog(s,code,s2,ii){
    if(ii==1){ 
        //输出hex类型
        var str =  bytesToHex(code)+s2;
        console.log(s+&quot; |HEX :&quot;+str);
        send(s+&quot; |HEX :&quot;+str);
        //输出base64
        str = bytesToBase64(code)+s2;
        console.log( s+&quot; |BASE64 :&quot;+str);
        send(s+&quot; |BASE64 :&quot;+str);
        //输出string类型
        str =  bytesToString(code)+s2;
        console.log(s+&quot; |str :&quot;+str);
        send(s+&quot; |str :&quot;+str);
    }else{
        console.log(s);
        send(s);
    }
};
Java.perform(function () {
    var secretKeySpec = Java.use('javax.crypto.spec.SecretKeySpec');
    var AE算法名称 = null;
    secretKeySpec.$init.overload('[B', 'java.lang.String').implementation = function (a, b) {
        showStacks();
        var result = this.$init(a, b);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(&quot;算法名：&quot; + b + &quot;| 密钥&quot; , a,&quot;&quot;,1);   
        AE算法名称=b;    
        return result;
    };
    secretKeySpec.$init.overload('[B', 'int','int','java.lang.String').implementation = function (a,i1,i2, b) {
        showStacks();
        var result = this.$init(a,i1,i2,b);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(&quot;算法名：&quot; + b + &quot;| 密钥&quot; , a,&quot;    |开始取的位置&quot;+i1+&quot;取长度:&quot;+i2,1);   
        AE算法名称=b;    
        return result;
    };
    var DESKeySpec = Java.use('javax.crypto.spec.DESKeySpec');
    DESKeySpec.$init.overload('[B').implementation = function (a) {
        showStacks();
        var result = this.$init(a);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        var bytes_key_des = this.getKey();
        mylog(&quot;des密钥 &quot; ,bytes_key_des,&quot;&quot;,1);        
        return result;
    };
    DESKeySpec.$init.overload('[B', 'int').implementation = function (a, b) {
        showStacks();
        var result = this.$init(a, b);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        var bytes_key_des = this.getKey();
        mylog(&quot;des密钥 &quot; , bytes_key_des,&quot;&quot;,1);      
        return result;
    };
    //3des
    var DESedeKeySpec = Java.use('javax.crypto.spec.DESedeKeySpec');
    DESedeKeySpec.$init.overload('[B').implementation = function (a) {
        showStacks();
        var result = this.$init(a);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        var bytes_key_des = this.getKey();
        mylog(&quot;des密钥 &quot; ,bytes_key_des,&quot;&quot;,1);        
        return result;
    };
    DESedeKeySpec.$init.overload('[B', 'int').implementation = function (a, b) {
        showStacks();
        var result = this.$init(a, b);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        var bytes_key_des = this.getKey();
        mylog(&quot;des密钥 &quot; , bytes_key_des,&quot;&quot;,1);      
        return result;
    };
    var mac = Java.use('javax.crypto.Mac');
    var MAC算法名称=null;
    mac.getInstance.overload('java.lang.String').implementation = function (a) {
        showStacks();
        var result = this.getInstance(a);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(&quot;Mac算法名：&quot; + a,&quot;&quot;,&quot;&quot;,0);
        MAC算法名称 =a;
        return result;
    };
    mac.update.overload('[B').implementation = function (a) {
        showStacks();
        this.update(a);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(MAC算法名称+&quot;update:&quot; ,a,&quot;&quot;,1);
    };
    mac.update.overload('[B', 'int', 'int').implementation = function (a, b, c) {
        showStacks();
        this.update(a, b, c);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(MAC算法名称+&quot;update:&quot; , a , &quot;|&quot; + b + &quot;|&quot; + c,1);      
    };
    mac.update.overload('java.nio.ByteBuffer').implementation = function (a) {
        showStacks();
        this.update(a);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(MAC算法名称+&quot;update:&quot; ,a.array() , &quot;&quot;,1);      
    };
    mac.doFinal.overload().implementation = function () {
        showStacks();
        var result = this.doFinal();
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(MAC算法名称+&quot;doFinal结果:&quot;, result,&quot;&quot;,1);
        return result;
    };
    mac.doFinal.overload('[B').implementation = function (a) {
        showStacks();
        var result = this.doFinal(a);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(MAC算法名称+&quot;doFinal参数:&quot;,a,&quot;&quot;,1);
        return result;
    };
    mac.doFinal.overload('[B','int').implementation = function (a,b) {
        showStacks();
        var result = this.doFinal(a,b);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(MAC算法名称+&quot;doFinal参数:&quot;,a,&quot;  |  &quot;+b,1);
        return result;
    };
    var md = Java.use('java.security.MessageDigest');
    var HX算法名称=null;
    md.getInstance.overload('java.lang.String', 'java.lang.String').implementation = function (a, b) {
        showStacks();
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(&quot;算法名：&quot; + a,&quot;&quot;,&quot;&quot;,0);
        HX算法名称 = a;
        return this.getInstance(a, b);
    };
    md.getInstance.overload('java.lang.String', 'java.security.Provider').implementation = function (a, b) {
        showStacks();
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(&quot;算法名：&quot; + a,&quot;&quot;,&quot;&quot;,0);
        HX算法名称 = a;
        return this.getInstance(a, b);
    };
    md.getInstance.overload('java.lang.String').implementation = function (a) {
        showStacks();
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(&quot;算法名：&quot; + a,&quot;&quot;,&quot;&quot;,0);
        HX算法名称 = a;
        return this.getInstance(a);
    };
    md.update.overload('[B').implementation = function (a) {
        showStacks();
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(HX算法名称+&quot;_update:&quot; , a,&quot;&quot;,1);     
        return this.update(a);
    };
    md.update.overload('[B', 'int', 'int').implementation = function (a, b, c) {
        showStacks();
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(HX算法名称+&quot;_update:&quot; , a , &quot;|&quot; + b + &quot;|&quot; + c,1);       
        return this.update(a, b, c);
    };
    md.update.overload('java.nio.ByteBuffer').implementation = function (a) {
        showStacks();
        this.update(a);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(HX算法名称+&quot;update:&quot; ,a.array() , &quot;&quot;,1);      
    };
    md.digest.overload().implementation = function () {
        showStacks();
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        var result = this.digest();
        mylog(HX算法名称+&quot;_digest结果:&quot; , result,&quot;&quot;,1);        
        return result;
    };
    md.digest.overload('[B').implementation = function (a) {
        showStacks();
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(HX算法名称+&quot;_digest参数:&quot; , a,&quot;&quot;,1);
        var result = this.digest(a);
        mylog(HX算法名称+&quot;_digest结果:&quot; , result,&quot;&quot;,1);        
        return result;
    } ; 
    md.digest.overload('[B','int','int').implementation = function (a,b,c) {
        showStacks();
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(HX算法名称+&quot;_digest参数:&quot; , a,&quot;   |&quot;+b+&quot;|&quot;+c,1);
        var result = this.digest(a,b,c);
        mylog(HX算法名称+&quot;_digest结果:&quot; , result,&quot;&quot;,1);        
        return result;
    };
    var ivParameterSpec = Java.use('javax.crypto.spec.IvParameterSpec');
    ivParameterSpec.$init.overload('[B').implementation = function (a) {
        showStacks();
        var result = this.$init(a);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(&quot;iv向量: &quot; ,a,&quot;&quot;,1);
        return result;
    };
    var ivParameterSpec = Java.use('javax.crypto.spec.IvParameterSpec');
    ivParameterSpec.$init.overload('[B','int','int').implementation = function (a,b,c) {
        showStacks();
        var result = this.$init(a,b,c);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(&quot;iv向量: &quot; ,a,&quot;   |&quot;+b+&quot;|&quot;+c,1);
        return result;
    };
    var cipher = Java.use('javax.crypto.Cipher');
    cipher.getInstance.overload('java.lang.String').implementation = function (a) {
        showStacks();
        var result = this.getInstance(a);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(AE算法名称+&quot;_模式填充:&quot; + a,&quot;&quot;,&quot;&quot;,0);
        return result;
    };
    cipher.init.overload('int', 'java.security.Key').implementation = function (a, b) {
        showStacks();
        var result = this.init(a, b);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        if (N_ENCRYPT_MODE == a) 
        {
            mylog(AE算法名称+&quot;_init  | 加密模式&quot;,&quot;&quot;,&quot;&quot;,0);    
        }
        else if(N_DECRYPT_MODE == a)
        {
            mylog(AE算法名称+&quot;_init  | 解密模式&quot;,&quot;&quot;,&quot;&quot;,0);    
        };
        var bytes_key = b.getEncoded();
        mylog(AE算法名称+&quot;_init key:&quot; + &quot;|密钥&quot; , bytes_key,&quot;&quot;,1);       
        return result;
    };
    cipher.init.overload('int', 'java.security.cert.Certificate').implementation = function (a, b) {
        showStacks();
        var result = this.init(a, b);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        if (N_ENCRYPT_MODE == a) 
        {
            mylog(AE算法名称+&quot;_init  | 加密模式&quot;,&quot;&quot;,&quot;&quot;,0);    
        }
        else if(N_DECRYPT_MODE == a)
        {
            mylog(AE算法名称+&quot;_init  | 解密模式&quot;,&quot;&quot;,&quot;&quot;,0);    
        };
        return result;
    };
    cipher.init.overload('int', 'java.security.Key', 'java.security.spec.AlgorithmParameterSpec').implementation = function (a, b, c) {
        showStacks();
        var result = this.init(a, b, c);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        if (N_ENCRYPT_MODE == a) 
        {
            mylog(AE算法名称+&quot;_init  | 加密模式&quot;,&quot;&quot;,&quot;&quot;,0);    
        }
        else if(N_DECRYPT_MODE == a)
        {
            mylog(AE算法名称+&quot;_init  | 解密模式&quot;,&quot;&quot;,&quot;&quot;,0);    
        };
        var bytes_key = b.getEncoded();
        mylog(AE算法名称+&quot;_init key:&quot; + &quot;|密钥&quot; ,bytes_key,&quot;&quot;,1); 
        return result;
    };
    cipher.init.overload('int', 'java.security.cert.Certificate', 'java.security.SecureRandom').implementation = function (a, b, c) {
        showStacks();
        var result = this.init(a, b, c);
        if (N_ENCRYPT_MODE == a) 
        {
            mylog(AE算法名称+&quot;_init  | 加密模式&quot;,&quot;&quot;,&quot;&quot;,0);    
        }
        else if(N_DECRYPT_MODE == a)
        {
            mylog(AE算法名称+&quot;_init  | 解密模式&quot;,&quot;&quot;,&quot;&quot;,0);    
        };
        return result;
    };
    cipher.init.overload('int', 'java.security.Key', 'java.security.SecureRandom').implementation = function (a, b, c) {
        showStacks();
        var result = this.init(a, b, c);
        if (N_ENCRYPT_MODE == a) 
        {
            mylog(AE算法名称+&quot;_init  | 加密模式&quot;,&quot;&quot;,&quot;&quot;,0);    
        }
        else if(N_DECRYPT_MODE == a)
        {
            mylog(AE算法名称+&quot;_init  | 解密模式&quot;,&quot;&quot;,&quot;&quot;,0);    
        };
         var bytes_key = b.getEncoded();
        mylog(AE算法名称+&quot;_init key:&quot; + &quot;密钥:&quot; , bytes_key,&quot;&quot;,1);       
        return result;
    };
    cipher.init.overload('int', 'java.security.Key', 'java.security.AlgorithmParameters').implementation = function (a, b, c) {
        showStacks();
        var result = this.init(a, b, c);
        if (N_ENCRYPT_MODE == a) 
        {
           mylog(AE算法名称+&quot;_init  | 加密模式&quot;,&quot;&quot;,&quot;&quot;,0);    
        }
        else if(N_DECRYPT_MODE == a)
        {
            mylog(AE算法名称+&quot;_init  | 解密模式&quot;,&quot;&quot;,&quot;&quot;,0);    
        };
        var bytes_key = b.getEncoded();
        mylog(AE算法名称+&quot;_init key:&quot; + &quot;密钥:&quot; , bytes_key,&quot;&quot;,1);
        return result;
    };
    cipher.init.overload('int', 'java.security.Key', 'java.security.AlgorithmParameters', 'java.security.SecureRandom').implementation = function (a, b, c, d) {
        showStacks();
        var result = this.init(a, b, c, d);
        if (N_ENCRYPT_MODE == a) 
        {
            mylog(AE算法名称+&quot;_init  | 加密模式&quot;,&quot;&quot;,&quot;&quot;,0);    
        }
        else if(N_DECRYPT_MODE == a)
        {
            mylog(AE算法名称+&quot;_init  | 解密模式&quot;,&quot;&quot;,&quot;&quot;,0);    
        }
        var bytes_key = b.getEncoded();
        mylog(AE算法名称+&quot;_init key:&quot; + &quot;密钥:&quot; , bytes_key,&quot;&quot;,1);        
        return result;
    };
    cipher.init.overload('int', 'java.security.Key', 'java.security.spec.AlgorithmParameterSpec', 'java.security.SecureRandom').implementation = function (a, b, c, d) {
        showStacks();
        var result = this.update(a, b, c, d);
        if (N_ENCRYPT_MODE == a) 
        {
            mylog(AE算法名称+&quot;_init  | 加密模式&quot;,&quot;&quot;,&quot;&quot;,0);    
        }
        else if(N_DECRYPT_MODE == a)
        {
            mylog(AE算法名称+&quot;_init  | 解密模式&quot;,&quot;&quot;,&quot;&quot;,0);    
        };
         var bytes_key = b.getEncoded();
        mylog(AE算法名称+&quot;_init key:&quot; + &quot;|密钥:&quot; ,bytes_key,&quot;&quot;,1);       
        return result;
    };
    cipher.update.overload('[B').implementation = function (a) {
        showStacks();
        var result = this.update(a);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(AE算法名称+&quot;_update:&quot; , a,&quot;&quot;,1);  
        return result;
    };
    cipher.update.overload('[B', 'int', 'int').implementation = function (a, b, c) {
        showStacks();
        var result = this.update(a, b, c);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(AE算法名称+&quot;_update: &quot; , a , &quot;|&quot; + b + &quot;|&quot; + c,1);
        return result;
    };
    cipher.update.overload('[B', 'int', 'int','[B').implementation = function (a, b, c,d) {
        showStacks();
        var result = this.update(a, b, c, d);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(AE算法名称+&quot;_update: &quot; , a , &quot;|&quot; + b + &quot;|&quot; + c,1);
        mylog(AE算法名称+&quot;_update:结果: &quot; , d , &quot;|&quot; + b + &quot;|&quot; + c,1);
        return result;
    };
    cipher.update.overload('[B', 'int', 'int','[B','int').implementation = function (a, b, c,d,e) {
        showStacks();
        var result = this.update(a, b, c, d,e);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(AE算法名称+&quot;_update: &quot; , a , &quot;|&quot; + b + &quot;|&quot; + c + &quot;|&quot; + e,1);
        mylog(AE算法名称+&quot;_update:结果: &quot; , d , &quot;|&quot; + b + &quot;|&quot; + c+ &quot;|&quot; + e,1);
        return result;
    }  ;  
    cipher.update.overload('java.nio.ByteBuffer', 'java.nio.ByteBuffer').implementation = function (a, b) {
        showStacks();
        var result = this.update(a,b);        
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(AE算法名称+&quot;(ByteBuffer)_update: &quot; , a.array() ,&quot;&quot;,1);
        mylog(AE算法名称+&quot;(ByteBuffer)_update:结果: &quot; , b.array(), &quot;&quot; ,1);
        return result;
    };
    cipher.doFinal.overload().implementation = function () {
        showStacks();
        var result = this.doFinal();
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(AE算法名称+&quot;_doFinal结果: &quot;,result,&quot;&quot;,1);
        return result;
    };
    cipher.doFinal.overload('[B').implementation = function (a) {
        showStacks();
        var result = this.doFinal(a);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(AE算法名称+&quot;_doFinal参数: &quot; ,a,&quot;&quot;,1);
        mylog(AE算法名称+&quot;_doFinal结果: &quot;,result,&quot;&quot;,1);
        return result;
    };
    cipher.doFinal.overload('[B','int').implementation = function (a,b) {
        showStacks();
        var result = this.doFinal(a,b);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);        
        mylog(AE算法名称+&quot;_doFinal结果: &quot;, a,&quot;   |&quot;+b,1);
        return result;
    };
    cipher.doFinal.overload('[B','int','int').implementation = function (a,b,c) {
        showStacks();
        var result = this.doFinal(a,b,c);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);        
        mylog(AE算法名称+&quot;_doFinal参数: &quot; ,a,&quot;   |&quot;+b+&quot;|&quot;+c,1);
        mylog(AE算法名称+&quot;_doFinal结果: &quot;,result,&quot;&quot;,1);
        return result;
    };
    cipher.doFinal.overload('[B','int','int','[B','int').implementation = function (a,b,c,d,e) {
        showStacks();
        var result = this.doFinal(a,b,c,d,e);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);        
        mylog(AE算法名称+&quot;_doFinal参数: &quot; ,a,&quot;   |&quot;+b+&quot;|&quot;+c,1);
        mylog(AE算法名称+&quot;_doFinal结果: &quot;,d,&quot;  |&quot;+e,1);
        return result;
    };
    cipher.doFinal.overload('[B','int','int','[B').implementation = function (a,b,c,d) {
        showStacks();
        var result = this.doFinal(a,b,c,d);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);        
        mylog(AE算法名称+&quot;_doFinal参数: &quot; ,a,&quot;   |&quot;+b+&quot;|&quot;+c,1);
        mylog(AE算法名称+&quot;_doFinal结果: &quot;,d,&quot;&quot;,1);
        return result;
    };
    var x509EncodedKeySpec = Java.use('java.security.spec.X509EncodedKeySpec');
    x509EncodedKeySpec.$init.overload('[B').implementation = function (a) {
        showStacks();
        var result = this.$init(a);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(&quot;RSA公钥:&quot; + bytesToBase64(a),&quot;&quot;,&quot;&quot;,0);
        return result;
    };
    
    var PKCS8EncodedKeySpec = Java.use('java.security.spec.PKCS8EncodedKeySpec');
    PKCS8EncodedKeySpec.$init.overload('[B').implementation = function (a) {
        showStacks();
        var result = this.$init(a);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(&quot;RSA私钥:&quot; + bytesToBase64(a),&quot;&quot;,&quot;&quot;,0);
        return result;
    };
    var rSAPublicKeySpec = Java.use('java.security.spec.RSAPublicKeySpec');
    rSAPublicKeySpec.$init.overload('java.math.BigInteger', 'java.math.BigInteger').implementation = function (a, b) {
        showStacks();
        var result = this.$init(a, b);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        //console.log(&quot;RSA公钥:&quot; + bytesToBase64(a));
        mylog(&quot;RSA密钥N:&quot; + a.toString(16),&quot;&quot;,&quot;&quot;,0);
        mylog(&quot;RSA密钥E:&quot; + b.toString(16),&quot;&quot;,&quot;&quot;,0);
        return result;
    };
    var KeyPairGenerator = Java.use('java.security.KeyPairGenerator');
    KeyPairGenerator.generateKeyPair.implementation = function () 
    {
        showStacks();
        var result = this.generateKeyPair();
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        var str_private = result.getPrivate().getEncoded();
        var str_public = result.getPublic().getEncoded();
        mylog(&quot;公钥 |hex:&quot; + bytesToHex(str_public),&quot;&quot;,&quot;&quot;,0);
        mylog(&quot;私钥 |hex:&quot; + bytesToHex(str_private),&quot;&quot;,&quot;&quot;,0);
        return result;
    };
    KeyPairGenerator.genKeyPair.implementation = function () 
    {
        showStacks();
        var result = this.genKeyPair();
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        var str_private = result.getPrivate().getEncoded();
        var str_public = result.getPublic().getEncoded();
        mylog(&quot;公钥 |hex:&quot; + bytesToHex(str_public),&quot;&quot;,&quot;&quot;,0);
        mylog(&quot;私钥 |hex:&quot; + bytesToHex(str_private),&quot;&quot;,&quot;&quot;,0);
        return result;
    };
        //返回输出流
        var OutStream = Java.use('java.io.OutputStream');
        OutStream['write'].overload('[B').implementation = function(data) {   
            showStacks();
            var ret = this.write(data);
            mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
            mylog(&quot;TCP接收 输出流:&quot;,data,&quot;&quot; ,1);
            return ret;
        };
        //返回输出流
        OutStream['write'].overload('[B','int','int').implementation = function(data,a,b) {   
            showStacks();
            var ret = this.write(data,a,b);
            mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
            mylog(&quot;TCP接收 输出流:&quot;,data,&quot;  |&quot;+a+&quot;|&quot;+b  ,1);
            return ret;
        };
         //返回输入流
    var Stream = Java.use('java.io.InputStream');
    Java.use(&quot;java.net.Socket&quot;).getInputStream.overload().implementation=function(){
        showStacks();
        mylog(&quot;tcp 输入流======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        var rets = this.getInputStream()     
        return rets;
    };
    Stream['read'].overload('[B').implementation = function(data) {   
        mylog(&quot;tcp 输入流======================================&quot;,&quot;&quot;,&quot;&quot;,0);
            showStacks();
            var ret = this.read(data);
            mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
            mylog(&quot;tcp 输入流:&quot;,data,&quot;&quot; ,1);
            return ret;
        };
            //返回输入流
    Stream['read'].overload('[B','int','int').implementation = function(data,a,b) {  
        mylog(&quot;tcp 输入流======================================&quot;,&quot;&quot;,&quot;&quot;,0); 
        showStacks();
        var ret = this.read(data,a,b);
        mylog(&quot;======================================&quot;,&quot;&quot;,&quot;&quot;,0);
        mylog(&quot;tcp 输入流:&quot;,data,&quot;  |&quot;+a+&quot;|&quot;+b ,1);
        return ret;
    };
});
    '''
    return htmlstr


def mians(pakname):
    print(pakname)
    jscod = get_js()
    process = frida.get_device_manager().add_remote_device(&quot;127.0.0.1:8080&quot;).attach(pakname)
    script = process.create_script(jscod)
    script.on(&quot;message&quot;, on_message)
    script.load()
    sys.stdin.read()


if __name__ == &quot;__main__&quot;:
    mians(&quot;App名&quot;)  # App name

</code></pre>
<h1 id="三-hook方法一">三、hook方法一</h1>
<pre><code>function showStacks() {
    Java.perform(function () {
      console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()));
    });
}

var base64EncodeChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
base64DecodeChars = new Array((-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), (-1), 62, (-1), (-1), (-1), 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, (-1), (-1), (-1), (-1), (-1), (-1), (-1), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, (-1), (-1), (-1), (-1), (-1), (-1), 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, (-1), (-1), (-1), (-1), (-1));
var stringToBase64 = function (e) {
    var r,a,c,h,o,t;
    for (c = e.length, a = 0, r = ''; a &lt; c; ) {
        if (h = 255 &amp; e.charCodeAt(a++), a == c) {
            r += base64EncodeChars.charAt(h &gt;&gt; 2),
            r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4),
            r += '==';
            break
        }
        if (o = e.charCodeAt(a++), a == c) {
            r += base64EncodeChars.charAt(h &gt;&gt; 2),
            r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4),
            r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2),
            r += '=';
            break
        }
        t = e.charCodeAt(a++),
        r += base64EncodeChars.charAt(h &gt;&gt; 2),
        r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4),
        r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2 | (192 &amp; t) &gt;&gt; 6),
        r += base64EncodeChars.charAt(63 &amp; t)
    }
    return r
}
var base64ToString = function (e) {
    var r,a,c,h,o,t,d;
    for (t = e.length, o = 0, d = ''; o &lt; t; ) {
        do
            r = base64DecodeChars[255 &amp; e.charCodeAt(o++)];
        while (o &lt; t &amp;&amp; r == -1);
        if (r == -1)
            break;
        do
            a = base64DecodeChars[255 &amp; e.charCodeAt(o++)];
        while (o &lt; t &amp;&amp; a == -1);
        if (a == -1)
            break;
        d += String.fromCharCode(r &lt;&lt; 2 | (48 &amp; a) &gt;&gt; 4);
        do {
            if (c = 255 &amp; e.charCodeAt(o++), 61 == c)
                return d;
            c = base64DecodeChars[c]
        } while (o &lt; t &amp;&amp; c == -1);
        if (c == -1)
            break;
        d += String.fromCharCode((15 &amp; a) &lt;&lt; 4 | (60 &amp; c) &gt;&gt; 2);
        do {
            if (h = 255 &amp; e.charCodeAt(o++), 61 == h)
                return d;
            h = base64DecodeChars[h]
        } while (o &lt; t &amp;&amp; h == -1);
        if (h == -1)
            break;
        d += String.fromCharCode((3 &amp; c) &lt;&lt; 6 | h)
    }
    return d
}
var hexToBase64 = function (str) {
    return base64Encode(String.fromCharCode.apply(null, str.replace(/\r|\n/g, &quot;&quot;).replace(/([\da-fA-F]{2}) ?/g, &quot;0x$1 &quot;).replace(/ +$/, &quot;&quot;).split(&quot; &quot;)));
}
var base64ToHex = function (str) {
    for (var i = 0, bin = base64Decode(str.replace(/[ \r\n]+$/, &quot;&quot;)), hex = []; i &lt; bin.length; ++i) {
        var tmp = bin.charCodeAt(i).toString(16);
        if (tmp.length === 1)
            tmp = &quot;0&quot; + tmp;
        hex[hex.length] = tmp;
    }
    return hex.join(&quot;&quot;);
}
var hexToBytes = function (str) {
    var pos = 0;
    var len = str.length;
    if (len % 2 != 0) {
        return null;
    }
    len /= 2;
    var hexA = new Array();
    for (var i = 0; i &lt; len; i++) {
        var s = str.substr(pos, 2);
        var v = parseInt(s, 16);
        hexA.push(v);
        pos += 2;
    }
    return hexA;
}
var bytesToHex = function (arr) {
    var str = '';
    var k,j;
    for(var i = 0; i&lt;arr.length; i++) {
        k = arr[i];
        j = k;
        if (k &lt; 0) {
            j = k + 256;
        }
        if (j &lt; 16) {
            str += &quot;0&quot;;
        }
        str += j.toString(16);
    }
    return str;
}
var stringToHex = function (str) {
    var val = &quot;&quot;;
    for (var i = 0; i &lt; str.length; i++) {
        if (val == &quot;&quot;)
            val = str.charCodeAt(i).toString(16);
        else
            val += str.charCodeAt(i).toString(16);
    }
    return val
}
var stringToBytes = function (str) {  
    var ch, st, re = []; 
    for (var i = 0; i &lt; str.length; i++ ) { 
        ch = str.charCodeAt(i);  
        st = [];                 
       do {  
            st.push( ch &amp; 0xFF );  
            ch = ch &gt;&gt; 8;          
        }    
        while ( ch );  
        re = re.concat( st.reverse() ); 
    }  
    return re;  
} 
//将byte[]转成String的方法
var bytesToString = function (arr) {  
    var str = '';
    var i;
    arr = new Uint8Array(arr);
    for(i in arr){
        str += String.fromCharCode(arr[i]);
    }
    return str;
}
var bytesToBase64=function(e){
    var r,a,c,h,o,t;
    for (c = e.length, a = 0, r = ''; a &lt; c; ) {
        if (h = 255 &amp; e[a++], a == c) {
            r += base64EncodeChars.charAt(h &gt;&gt; 2),
            r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4),
            r += '==';
            break
        }
        if (o = e[a++], a == c) {
            r += base64EncodeChars.charAt(h &gt;&gt; 2),
            r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4),
            r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2),
            r += '=';
            break
        }
        t = e[a++],
        r += base64EncodeChars.charAt(h &gt;&gt; 2),
        r += base64EncodeChars.charAt((3 &amp; h) &lt;&lt; 4 | (240 &amp; o) &gt;&gt; 4),
        r += base64EncodeChars.charAt((15 &amp; o) &lt;&lt; 2 | (192 &amp; t) &gt;&gt; 6),
        r += base64EncodeChars.charAt(63 &amp; t)
    }
    return r
}
var base64ToBytes=function(e){
    var r,a,c,h,o,t,d;
    for (t = e.length, o = 0, d = []; o &lt; t; ) {
        do
            r = base64DecodeChars[255 &amp; e.charCodeAt(o++)];
        while (o &lt; t &amp;&amp; r == -1);
        if (r == -1)
            break;
        do
            a = base64DecodeChars[255 &amp; e.charCodeAt(o++)];
        while (o &lt; t &amp;&amp; a == -1);
        if (a == -1)
            break;
        d.push(r &lt;&lt; 2 | (48 &amp; a) &gt;&gt; 4);
        do {
            if (c = 255 &amp; e.charCodeAt(o++), 61 == c)
                return d;
            c = base64DecodeChars[c]
        } while (o &lt; t &amp;&amp; c == -1);
        if (c == -1)
            break;
        d.push((15 &amp; a) &lt;&lt; 4 | (60 &amp; c) &gt;&gt; 2);
        do {
            if (h = 255 &amp; e.charCodeAt(o++), 61 == h)
                return d;
            h = base64DecodeChars[h]
        } while (o &lt; t &amp;&amp; h == -1);
        if (h == -1)
            break;
        d.push((3 &amp; c) &lt;&lt; 6 | h)
    }
    return d
}

//stringToBase64 stringToHex stringToBytes
//base64ToString base64ToHex base64ToBytes
//               hexToBase64  hexToBytes    
// bytesToBase64 bytesToHex bytesToString
Java.perform(function () {
var secretKeySpec = Java.use('javax.crypto.spec.SecretKeySpec');
secretKeySpec.$init.overload('[B','java.lang.String').implementation = function (a,b) {
    showStacks();
    var result = this.$init(a, b);
    console.log(&quot;======================================&quot;);
    console.log(&quot;算法名：&quot; + b + &quot;|Dec密钥:&quot; + bytesToString(a));
    console.log(&quot;算法名：&quot; + b + &quot;|Hex密钥:&quot; + bytesToHex(a));
    return result;
}
var mac = Java.use('javax.crypto.Mac');
mac.getInstance.overload('java.lang.String').implementation = function (a) {
    showStacks();
    var result = this.getInstance(a);
    console.log(&quot;======================================&quot;);
    console.log(&quot;算法名：&quot; + a);
    return result;
}
mac.update.overload('[B').implementation = function (a) {
    showStacks();
    this.update(a);
    console.log(&quot;======================================&quot;);
    console.log(&quot;update:&quot; + bytesToString(a))
}
mac.update.overload('[B','int','int').implementation = function (a,b,c) {
    showStacks();
    this.update(a,b,c)
    console.log(&quot;======================================&quot;);
    console.log(&quot;update:&quot; + bytesToString(a) + &quot;|&quot; + b + &quot;|&quot; + c);
}
mac.doFinal.overload().implementation = function () {
    showStacks();
    var result = this.doFinal();
    console.log(&quot;======================================&quot;);
    console.log(&quot;doFinal结果:&quot; + bytesToHex(result));
    console.log(&quot;doFinal结果:&quot; + bytesToBase64(result));
    return result;
}
mac.doFinal.overload('[B').implementation = function (a) {
    showStacks();
    var result = this.doFinal(a);
    console.log(&quot;======================================&quot;);
    console.log(&quot;doFinal参数:&quot; + bytesToString(a));
    console.log(&quot;doFinal结果:&quot; + bytesToHex(result));
    console.log(&quot;doFinal结果:&quot; + bytesToBase64(result));
    return result;
}
    var md = Java.use('java.security.MessageDigest');
md.getInstance.overload('java.lang.String','java.lang.String').implementation = function (a,b) {
    showStacks();
    console.log(&quot;======================================&quot;);
    console.log(&quot;算法名：&quot; + a);
    return this.getInstance(a, b);
}
md.getInstance.overload('java.lang.String').implementation = function (a) {
    showStacks();
    console.log(&quot;======================================&quot;);
    console.log(&quot;算法名：&quot; + a);
    return this.getInstance(a);
}
md.update.overload('[B').implementation = function (a) {
    showStacks();
    console.log(&quot;======================================&quot;);
    console.log(&quot;update:&quot; + bytesToString(a))
    return this.update(a);
}
md.update.overload('[B','int','int').implementation = function (a,b,c) {
    showStacks();
    console.log(&quot;======================================&quot;);
    console.log(&quot;update:&quot; + bytesToString(a) + &quot;|&quot; + b + &quot;|&quot; + c);
    return this.update(a,b,c);
}
md.digest.overload().implementation = function () {
    showStacks();
    console.log(&quot;======================================&quot;);
    var result = this.digest();
    console.log(&quot;digest结果:&quot; + bytesToHex(result));
    console.log(&quot;digest结果:&quot; + bytesToBase64(result));
    return result;
}
md.digest.overload('[B').implementation = function (a) {
    showStacks();
    console.log(&quot;======================================&quot;);
    console.log(&quot;digest参数:&quot; + bytesToString(a));
    var result = this.digest(a);
    console.log(&quot;digest结果:&quot; + bytesToHex(result));
    console.log(&quot;digest结果:&quot; + bytesToBase64(result));
    return result;
}
    var ivParameterSpec = Java.use('javax.crypto.spec.IvParameterSpec');
ivParameterSpec.$init.overload('[B').implementation = function (a) {
    showStacks();
    var result = this.$init(a);
    console.log(&quot;======================================&quot;);
    console.log(&quot;iv向量:&quot; + bytesToString(a));
    console.log(&quot;iv向量:&quot; + bytesToHex(a));
    return result;
}
var cipher = Java.use('javax.crypto.Cipher');
cipher.getInstance.overload('java.lang.String').implementation = function (a) {
    showStacks();
    var result = this.getInstance(a);
    console.log(&quot;======================================&quot;);
    console.log(&quot;模式填充:&quot; + a);
    return result;
}
cipher.update.overload('[B').implementation = function (a) {
    showStacks();
    var result = this.update(a);
    console.log(&quot;======================================&quot;);
    console.log(&quot;update:&quot; + bytesToString(a));
    return result;
}
cipher.update.overload('[B','int','int').implementation = function (a,b,c) {
    showStacks();
    var result = this.update(a,b,c);
    console.log(&quot;======================================&quot;);
    console.log(&quot;update:&quot; + bytesToString(a) + &quot;|&quot; + b + &quot;|&quot; + c);
    return result;
}
cipher.doFinal.overload().implementation = function () {
    showStacks();
    var result = this.doFinal();
    console.log(&quot;======================================&quot;);
    console.log(&quot;doFinal结果:&quot; + bytesToHex(result));
    console.log(&quot;doFinal结果:&quot; + bytesToBase64(result));
    return result;
}
cipher.doFinal.overload('[B').implementation = function (a) {
    showStacks();
    var result = this.doFinal(a);
    console.log(&quot;======================================&quot;);
    console.log(&quot;doFinal参数:&quot; + bytesToString(a));
    console.log(&quot;doFinal结果:&quot; + bytesToHex(result));
    console.log(&quot;doFinal结果:&quot; + bytesToBase64(result));
    return result;
}
var x509EncodedKeySpec = Java.use('java.security.spec.X509EncodedKeySpec');
x509EncodedKeySpec.$init.overload('[B').implementation = function (a) {
    showStacks();
    var result = this.$init(a);
    console.log(&quot;======================================&quot;);
    console.log(&quot;RSA密钥:&quot; + bytesToBase64(a));
    return result;
}
var rSAPublicKeySpec = Java.use('java.security.spec.RSAPublicKeySpec');
rSAPublicKeySpec.$init.overload('java.math.BigInteger','java.math.BigInteger').implementation = function (a,b) {
    showStacks();
    var result = this.$init(a,b);
    console.log(&quot;======================================&quot;);
    //console.log(&quot;RSA密钥:&quot; + bytesToBase64(a));
    console.log(&quot;RSA密钥N:&quot; + a.toString(16));
    console.log(&quot;RSA密钥E:&quot; + b.toString(16));
    return result;
}
});

</code></pre>
<p>转载自：https://blog.csdn.net/weixin_51111267/article/details/131303876?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPayColumn-1-131303876-blog-133276655.235%5Ev43%5Econtrol&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPayColumn-1-131303876-blog-133276655.235%5Ev43%5Econtrol&amp;utm_relevant_index=1</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://mezdosec.github.io/post/ios-ni-xiang-zhi-frida-jian-ce-rao-guo/">
                  <h3 class="post-title">
                    iOS逆向之frida检测绕过
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/aos@2.3.4/dist/aos.min.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
